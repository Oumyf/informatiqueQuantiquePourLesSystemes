#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Analyse du notebook RSA POST QUANTIQUE.ipynb
Localisation: Desktop/M√©moire/
V√©rification impl√©mentation 100% fait maison
"""

import os
import json
import re

def find_notebook_in_memoire():
    """Trouver le notebook dans le dossier M√©moire"""
    
    print("üîç RECHERCHE DANS DOSSIER M√âMOIRE")
    print("=" * 40)
    
    # Chemins possibles pour le dossier M√©moire
    memoire_paths = [
        r"C:\Users\USER\Desktop\M√©moire",
        r"C:\Users\USER\Desktop\Memoire", 
        r"C:\Users\USER\Desktop\m√©moire",
        r"C:\Users\USER\Desktop\memoire",
        r"C:\Users\Abdoul\Desktop\M√©moire",
        r"C:\Users\Abdoul\Desktop\Memoire"
    ]
    
    for memoire_path in memoire_paths:
        print(f"üîç Recherche dans: {memoire_path}")
        
        if os.path.exists(memoire_path):
            print(f"‚úÖ Dossier trouv√©: {memoire_path}")
            
            # Chercher le notebook dans ce dossier
            possible_notebooks = [
                "RSA POST QUANTIQUE.ipynb",
                "rsa post quantique.ipynb",
                "RSA_POST_QUANTIQUE.ipynb",
                "rsa_post_quantique.ipynb"
            ]
            
            for notebook_name in possible_notebooks:
                notebook_path = os.path.join(memoire_path, notebook_name)
                if os.path.exists(notebook_path):
                    print(f"‚úÖ NOTEBOOK TROUV√â: {notebook_path}")
                    return notebook_path
                else:
                    print(f"‚ùå Pas trouv√©: {notebook_name}")
            
            # Recherche plus large dans le dossier
            try:
                print(f"üîç Recherche √©largie dans {memoire_path}...")
                for root, dirs, files in os.walk(memoire_path):
                    for file in files:
                        if file.endswith('.ipynb') and 'rsa' in file.lower():
                            full_path = os.path.join(root, file)
                            print(f"‚úÖ Notebook RSA trouv√©: {full_path}")
                            return full_path
            except Exception as e:
                print(f"‚ö†Ô∏è Erreur recherche: {e}")
        else:
            print(f"‚ùå Dossier introuvable: {memoire_path}")
    
    return None

def analyze_notebook_content(notebook_path):
    """Analyser le contenu du notebook"""
    
    print(f"\nüìñ ANALYSE CONTENU NOTEBOOK")
    print("-" * 35)
    print(f"üìÅ Fichier: {notebook_path}")
    
    try:
        with open(notebook_path, 'r', encoding='utf-8', errors='ignore') as f:
            notebook_data = json.load(f)
        
        # Extraire les cellules de code
        code_cells = []
        all_code = ""
        
        cells = notebook_data.get('cells', [])
        print(f"üìä Total cellules: {len(cells)}")
        
        for i, cell in enumerate(cells):
            if cell.get('cell_type') == 'code':
                source = cell.get('source', [])
                if isinstance(source, list):
                    cell_code = ''.join(source)
                else:
                    cell_code = source
                
                code_cells.append({
                    'index': i,
                    'code': cell_code,
                    'execution_count': cell.get('execution_count'),
                    'outputs': cell.get('outputs', [])
                })
                
                all_code += cell_code + "\n"
        
        print(f"üìä Cellules de code: {len(code_cells)}")
        
        return all_code, code_cells
        
    except Exception as e:
        print(f"‚ùå Erreur lecture notebook: {e}")
        return "", []

def check_imports_homemade(all_code):
    """V√©rifier que les imports sont fait maison"""
    
    print(f"\nüìã V√âRIFICATION IMPORTS FAIT MAISON")
    print("-" * 45)
    
    # Extraire tous les imports
    import_lines = []
    lines = all_code.split('\n')
    
    for i, line in enumerate(lines, 1):
        line = line.strip()
        if line.startswith(('import ', 'from ')) and not line.startswith('#'):
            import_lines.append(line)
    
    print(f"üìä Imports trouv√©s: {len(import_lines)}")
    
    # Biblioth√®ques standard autoris√©es (fait maison)
    allowed_standard = {
        'math', 'random', 'time', 'datetime', 'os', 'sys',
        'hashlib', 'hmac', 'base64', 'json', 'secrets',
        'itertools', 'functools', 'collections', 'struct'
    }
    
    # Biblioth√®ques INTERDITES pour fait maison
    forbidden_external = {
        'cryptography', 'pycrypto', 'pycryptodome', 'crypto',
        'rsa', 'ecdsa', 'pyopenssl', 'nacl', 'gmpy2', 
        'primality', 'sympy', 'numpy', 'scipy'
    }
    
    clean_imports = []
    forbidden_found = []
    
    for imp_line in import_lines:
        # Extraire le nom du module
        if imp_line.startswith('import '):
            module = imp_line.split('import ')[1].split('.')[0].split(' ')[0].split(',')[0]
        elif imp_line.startswith('from '):
            module = imp_line.split('from ')[1].split('.')[0].split(' ')[0]
        else:
            continue
        
        module = module.strip()
        
        if module.lower() in forbidden_external:
            forbidden_found.append(imp_line)
            print(f"   ‚ùå INTERDIT: {imp_line}")
        elif module in allowed_standard:
            clean_imports.append(imp_line)
            print(f"   ‚úÖ AUTORIS√â: {imp_line}")
        else:
            # V√©rifier si c'est standard
            try:
                __import__(module)
                clean_imports.append(imp_line)
                print(f"   ‚úÖ STANDARD: {imp_line}")
            except ImportError:
                print(f"   ‚ö†Ô∏è INCONNU: {imp_line}")
    
    is_homemade = len(forbidden_found) == 0
    
    print(f"\nüìä R√âSULTAT IMPORTS:")
    print(f"   ‚úÖ Autoris√©s: {len(clean_imports)}")
    print(f"   ‚ùå Interdits: {len(forbidden_found)}")
    
    if is_homemade:
        print(f"\nüéâ IMPORTS 100% FAIT MAISON!")
        print("‚úÖ Aucune biblioth√®que cryptographique externe")
        print("‚úÖ Utilisation uniquement de Python standard")
    else:
        print(f"\n‚ùå IMPORTS EXTERNES D√âTECT√âS!")
        print("Ces biblioth√®ques ne sont pas 'fait maison':")
        for forbidden in forbidden_found:
            print(f"   ‚Ä¢ {forbidden}")
    
    return is_homemade

def analyze_crypto_functions(all_code):
    """Analyser les fonctions cryptographiques impl√©ment√©es"""
    
    print(f"\nüîê ANALYSE FONCTIONS CRYPTOGRAPHIQUES")
    print("-" * 45)
    
    # Patterns pour d√©tecter les impl√©mentations crypto
    crypto_patterns = [
        (r'def\s+([^(]*rsa[^(]*)\(', 'RSA'),
        (r'def\s+([^(]*generat[^(]*)\(', 'G√©n√©ration'),
        (r'def\s+([^(]*encrypt[^(]*)\(', 'Chiffrement'), 
        (r'def\s+([^(]*decrypt[^(]*)\(', 'D√©chiffrement'),
        (r'def\s+([^(]*sign[^(]*)\(', 'Signature'),
        (r'def\s+([^(]*verify[^(]*)\(', 'V√©rification'),
        (r'def\s+([^(]*key[^(]*)\(', 'Gestion cl√©s'),
    ]
    
    crypto_functions = []
    
    for pattern, func_type in crypto_patterns:
        matches = re.finditer(pattern, all_code, re.IGNORECASE | re.MULTILINE)
        for match in matches:
            func_name = match.group(1).strip()
            line_num = all_code[:match.start()].count('\n') + 1
            crypto_functions.append({
                'name': func_name,
                'type': func_type,
                'line': line_num
            })
    
    print(f"üîß Fonctions cryptographiques trouv√©es: {len(crypto_functions)}")
    
    if crypto_functions:
        for func in crypto_functions:
            print(f"   ‚úÖ {func['name']} - {func['type']} (ligne {func['line']})")
    else:
        print("   ‚ö†Ô∏è Aucune fonction cryptographique √©vidente")
    
    return crypto_functions

def analyze_math_algorithms(all_code):
    """Analyser les algorithmes math√©matiques"""
    
    print(f"\nüßÆ ANALYSE ALGORITHMES MATH√âMATIQUES") 
    print("-" * 45)
    
    # Patterns pour algorithmes math√©matiques fait maison
    math_patterns = [
        (r'def\s+[^(]*gcd[^(]*\(', 'PGCD'),
        (r'def\s+[^(]*inverse[^(]*\(', 'Inverse modulaire'),
        (r'def\s+[^(]*prime[^(]*\(', 'Test primalit√©'),
        (r'def\s+[^(]*miller[^(]*\(', 'Miller-Rabin'),
        (r'def\s+[^(]*fermat[^(]*\(', 'Test Fermat'),
        (r'def\s+[^(]*euler[^(]*\(', 'Fonction Euler'),
        (r'def\s+[^(]*totient[^(]*\(', 'Totient'),
        (r'pow\s*\([^)]+,\s*[^)]+,\s*[^)]+\)', 'Exponentiation modulaire'),
    ]
    
    math_algos = {}  # √âviter doublons
    
    for pattern, algo_type in math_patterns:
        matches = re.finditer(pattern, all_code, re.IGNORECASE)
        for match in matches:
            line_num = all_code[:match.start()].count('\n') + 1
            if algo_type not in math_algos:
                math_algos[algo_type] = line_num
    
    print(f"üßÆ Algorithmes math√©matiques: {len(math_algos)}")
    
    if math_algos:
        for algo_type, line_num in math_algos.items():
            print(f"   ‚úÖ {algo_type} (ligne {line_num})")
    else:
        print("   ‚ö†Ô∏è Aucun algorithme math√©matique √©vident")
    
    return math_algos

def check_post_quantum_content(all_code):
    """V√©rifier le contenu Post-Quantique"""
    
    print(f"\nüöÄ V√âRIFICATION CONTENU POST-QUANTIQUE")
    print("-" * 45)
    
    # Mots-cl√©s Post-Quantique
    pq_keywords = [
        'post.quantum', 'post.quantique', 'quantum.resistant',
        'quantum.safe', 'post_quantum', 'post_quantique',
        'pqc', 'quantum.computer', 'shor.algorithm'
    ]
    
    pq_found = []
    lines = all_code.split('\n')
    
    for i, line in enumerate(lines, 1):
        for keyword in pq_keywords:
            if re.search(keyword, line, re.IGNORECASE):
                pq_found.append({
                    'line': i,
                    'content': line.strip()[:80] + '...' if len(line.strip()) > 80 else line.strip()
                })
                break  # Une seule mention par ligne
    
    print(f"üîç Mentions Post-Quantique: {len(pq_found)}")
    
    if pq_found:
        for mention in pq_found[:3]:  # Afficher les 3 premi√®res
            print(f"   ‚úÖ Ligne {mention['line']}: {mention['content']}")
        if len(pq_found) > 3:
            print(f"   ... et {len(pq_found) - 3} autres mentions")
        return True
    else:
        print("   ‚ö†Ô∏è Pas de mention explicite Post-Quantique")
        return False

def main():
    """Analyse compl√®te du notebook RSA POST QUANTIQUE"""
    
    print("üîç ANALYSE NOTEBOOK RSA POST QUANTIQUE")
    print("üìç Localisation: Desktop/M√©moire/")
    print("üéØ V√©rification: 100% fait maison")
    print("=" * 60)
    
    # 1. Trouver le notebook
    notebook_path = find_notebook_in_memoire()
    
    if not notebook_path:
        print("\n‚ùå NOTEBOOK NON TROUV√â DANS M√âMOIRE")
        print("\nüí° V√âRIFICATIONS:")
        print("‚Ä¢ Le dossier s'appelle bien 'M√©moire' ?")
        print("‚Ä¢ Le fichier est bien 'RSA POST QUANTIQUE.ipynb' ?")
        print("‚Ä¢ Chemin: Desktop/M√©moire/RSA POST QUANTIQUE.ipynb")
        return
    
    # 2. Analyser le contenu
    all_code, code_cells = analyze_notebook_content(notebook_path)
    
    if not all_code:
        print("‚ùå Impossible de lire le contenu")
        return
    
    # 3. V√©rifier les imports
    imports_ok = check_imports_homemade(all_code)
    
    # 4. Analyser les fonctions crypto
    crypto_funcs = analyze_crypto_functions(all_code)
    
    # 5. Analyser les algorithmes math
    math_algos = analyze_math_algorithms(all_code)
    
    # 6. V√©rifier contenu Post-Quantique
    has_pq = check_post_quantum_content(all_code)
    
    # 7. VERDICT FINAL
    print(f"\n" + "="*60)
    print("üèÜ VERDICT FINAL")
    print("="*60)
    
    total_score = len(crypto_funcs) + len(math_algos)
    
    if imports_ok and total_score >= 5:
        print("üéâ EXCELLENT! NOTEBOOK 100% FAIT MAISON!")
        print("‚úÖ Imports: Biblioth√®ques standard uniquement")
        print(f"‚úÖ Impl√©mentation: {len(crypto_funcs)} fonctions crypto + {len(math_algos)} algos math")
        print(f"‚úÖ Score total: {total_score}")
        
        if has_pq:
            print("‚úÖ Innovation: Post-Quantique explicitement mentionn√©e")
        
        print(f"\nüîê VOTRE R√âALISATION FAIT MAISON:")
        print("‚Ä¢ Cryptographie RSA: Impl√©ment√©e personnellement")
        print("‚Ä¢ Algorithmes math√©matiques: Cod√©s manuellement")
        print("‚Ä¢ D√©pendances: Z√©ro biblioth√®que externe")
        print("‚Ä¢ Innovation: RSA Post-Quantique authentique")
        
        print(f"\nüèÜ CERTIFICATION 'FAIT MAISON' VALID√âE!")
        print("Parfait pour d√©monstration au jury!")
        
    elif imports_ok:
        print("‚úÖ BIEN! Imports propres")
        print("‚úÖ Aucune biblioth√®que cryptographique externe")
        print(f"‚ö†Ô∏è Impl√©mentation: {total_score} fonctions/algorithmes")
        print("‚ö†Ô∏è Peut n√©cessiter plus d'impl√©mentations")
        
    else:
        print("‚ùå IMPORTS EXTERNES D√âTECT√âS")
        print("‚ùå Notebook pas 100% fait maison")
        print("\nüí° Pour √™tre fait maison:")
        print("‚Ä¢ Supprimez les biblioth√®ques crypto externes")
        print("‚Ä¢ Utilisez seulement: math, random, hashlib")
        print("‚Ä¢ Impl√©mentez tout vous-m√™me")
    
    print(f"\nüìÅ NOTEBOOK ANALYS√â:")
    print(f"   {notebook_path}")

if __name__ == "__main__":
    main()